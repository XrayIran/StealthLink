#!/usr/bin/env bash
set -euo pipefail

SCRIPT_VERSION="5.0.0"

BIN_DIR="${STEALTHLINK_BIN_DIR:-/usr/local/bin}"
ETC_DIR="${STEALTHLINK_ETC_DIR:-/etc/stealthlink}"
LIB_DIR="${STEALTHLINK_LIB_DIR:-/var/lib/stealthlink}"
LOG_DIR="${STEALTHLINK_LOG_DIR:-/var/log/stealthlink}"
SYSTEMD_DIR="${STEALTHLINK_SYSTEMD_DIR:-/etc/systemd/system}"

GATEWAY_UNIT="stealthlink-gateway.service"
AGENT_UNIT="stealthlink-agent.service"
GATEWAY_BIN="stealthlink-gateway"
AGENT_BIN="stealthlink-agent"
TOOLS_BIN="stealthlink-tools"
STEALTHLINK_BIN="stealthlink"
GATEWAY_CFG="${ETC_DIR}/gateway.yaml"
AGENT_CFG="${ETC_DIR}/agent.yaml"
STATE_DIR="${LIB_DIR}/state"
BACKUP_DIR="${LIB_DIR}/backups"
FIREWALL_STATE_DIR="${LIB_DIR}/firewall"
FIREWALL_STATE_FILE="${FIREWALL_STATE_DIR}/state.json"
HOSTOPT_TOKEN_FILE="${LIB_DIR}/hostopt-last-token"

TMP_DIR=""
BUNDLE_ROOT=""
os_id="unknown"
os_family="unknown"
pkg_mgr="unknown"

if [[ -t 1 ]]; then
  C_RESET=$'\033[0m'; C_RED=$'\033[0;31m'; C_GREEN=$'\033[0;32m'; C_YELLOW=$'\033[0;33m'; C_BLUE=$'\033[0;34m'; C_CYAN=$'\033[0;36m'; C_BOLD=$'\033[1m'; C_DIM=$'\033[2m'
else
  C_RESET=""; C_RED=""; C_GREEN=""; C_YELLOW=""; C_BLUE=""; C_CYAN=""; C_BOLD=""; C_DIM=""
fi

log_i(){ echo -e "${C_BLUE}[INFO]${C_RESET} $*"; }
log_ok(){ echo -e "${C_GREEN}[ OK ]${C_RESET} $*"; }
log_w(){ echo -e "${C_YELLOW}[WARN]${C_RESET} $*"; }
log_e(){ echo -e "${C_RED}[ERR ]${C_RESET} $*" >&2; }
die(){ log_e "$*"; exit 1; }

cleanup(){ [[ -n "${TMP_DIR}" && -d "${TMP_DIR}" ]] && rm -rf "${TMP_DIR}" || true; }
trap cleanup EXIT

ensure_dirs(){ mkdir -p "${BIN_DIR}" "${ETC_DIR}" "${LIB_DIR}" "${LOG_DIR}" "${STATE_DIR}" "${BACKUP_DIR}" "${FIREWALL_STATE_DIR}"; }

require_root(){
  if [[ "${EUID:-$(id -u)}" -ne 0 ]]; then
    if command -v sudo >/dev/null 2>&1; then exec sudo -E bash "$0" "$@"; fi
    die "Must run as root. Use: sudo $0"
  fi
}

reattach_tty(){
  if [[ "${STEALTHLINK_TTY_REATTACHED:-0}" == "1" ]]; then return 0; fi
  if [[ -t 0 && -t 1 && -t 2 ]]; then return 0; fi
  if [[ -r /dev/tty && -w /dev/tty ]] && (: </dev/tty) 2>/dev/null; then
    export STEALTHLINK_TTY_REATTACHED=1
    exec bash "$0" "$@" </dev/tty >/dev/tty 2>/dev/tty
  fi
}

print_banner(){ echo -e "${C_CYAN}StealthLink Control v${SCRIPT_VERSION}${C_RESET}"; }
ui_print(){
  if [[ -w /dev/tty ]]; then
    echo -e "$*" >/dev/tty
  else
    echo -e "$*" >&2
  fi
}
ui_printf(){
  if [[ -w /dev/tty ]]; then
    printf "$@" >/dev/tty
  else
    printf "$@" >&2
  fi
}
press_enter(){
  if [[ -r /dev/tty ]]; then
    echo "" >/dev/tty
    echo -e "${C_DIM}Press Enter to continue...${C_RESET}" >/dev/tty
    read -r </dev/tty || true
  else
    echo "" >&2
    echo -e "${C_DIM}Press Enter to continue...${C_RESET}" >&2
    read -r || true
  fi
}
read_input(){
  local p="$1" d="${2:-}" v=""
  if [[ -r /dev/tty ]]; then
    echo -ne "${C_CYAN}${p}${C_RESET} [${d}]: " >/dev/tty
    read -r v </dev/tty || true
  else
    echo -ne "${C_CYAN}${p}${C_RESET} [${d}]: " >&2
    read -r v || true
  fi
  printf "%s" "${v:-${d}}"
}
read_password(){
  local p="$1" v=""
  if [[ -r /dev/tty ]]; then
    echo -ne "${C_CYAN}${p}${C_RESET}: " >/dev/tty
    read -rs v </dev/tty || true
    echo "" >/dev/tty
  else
    echo -ne "${C_CYAN}${p}${C_RESET}: " >&2
    read -rs v || true
    echo "" >&2
  fi
  printf "%s" "${v}"
}
read_yesno(){
  local p="$1" d="${2:-y}" a="" h="[Y/n]"
  [[ "${d}" == "n" ]] && h="[y/N]"
  if [[ -r /dev/tty ]]; then
    echo -ne "${C_YELLOW}${p}${C_RESET} ${h}: " >/dev/tty
    read -r a </dev/tty || true
  else
    echo -ne "${C_YELLOW}${p}${C_RESET} ${h}: " >&2
    read -r a || true
  fi
  a="${a:-${d}}"
  [[ "${a}" =~ ^[Yy] ]]
}

select_menu(){
  local title="$1"; shift
  local -a opts=("$@")
  ui_print ""
  ui_print "${C_BOLD}${title}${C_RESET}"
  ui_print "${C_DIM}─────────────────────────────────────${C_RESET}"
  local i=1
  while (( i <= ${#opts[@]} )); do ui_printf "  ${C_GREEN}%2d)${C_RESET} %s\n" "$(( (i+1)/2 ))" "${opts[$i]}"; i=$((i+2)); done
  ui_print ""
  local sel idx
  sel=$(read_input "Select" "1")
  idx=$(( (sel-1)*2 + 1 ))
  if (( idx > 0 && idx < ${#opts[@]} )); then printf "%s" "${opts[$idx]}"; else printf "%s" "${opts[1]}"; fi
}

detect_os(){
  if [[ -f /etc/os-release ]]; then . /etc/os-release 2>/dev/null || true; os_id="${ID:-unknown}"; fi
  case "${os_id}" in
    ubuntu|debian|linuxmint|pop|elementary|kali|raspbian) os_family="debian" ;;
    fedora|centos|rhel|rocky|almalinux|amzn|amazon) os_family="rhel" ;;
    arch|manjaro|endeavouros) os_family="arch" ;;
    alpine) os_family="alpine" ;;
    opensuse*|sles) os_family="suse" ;;
    *) os_family="unknown" ;;
  esac
  if command -v apt-get >/dev/null 2>&1; then pkg_mgr="apt"
  elif command -v dnf >/dev/null 2>&1; then pkg_mgr="dnf"
  elif command -v yum >/dev/null 2>&1; then pkg_mgr="yum"
  elif command -v pacman >/dev/null 2>&1; then pkg_mgr="pacman"
  elif command -v apk >/dev/null 2>&1; then pkg_mgr="apk"
  elif command -v zypper >/dev/null 2>&1; then pkg_mgr="zypper"
  else pkg_mgr="unknown"; fi
}

map_pkg(){
  local base="$1"
  case "${pkg_mgr}" in
    apt) case "${base}" in iproute2) echo iproute2;; nftables) echo nftables;; iptables) echo iptables;; systemd-tools) echo systemd;; *) echo "${base}";; esac ;;
    dnf|yum) case "${base}" in iproute2) echo iproute;; systemd-tools) echo systemd;; *) echo "${base}";; esac ;;
    pacman) case "${base}" in iproute2) echo iproute2;; systemd-tools) echo systemd;; *) echo "${base}";; esac ;;
    apk) case "${base}" in iproute2) echo iproute2;; systemd-tools) echo openrc;; *) echo "${base}";; esac ;;
    zypper) case "${base}" in iproute2) echo iproute2;; systemd-tools) echo systemd;; *) echo "${base}";; esac ;;
    *) echo "${base}" ;;
  esac
}

pkg_install(){
  local -a pkgs=("$@")
  [[ "${pkg_mgr}" == "unknown" ]] && die "Unknown package manager. Install manually: ${pkgs[*]}"
  log_i "Installing packages: ${pkgs[*]}"
  case "${pkg_mgr}" in
    apt) export DEBIAN_FRONTEND=noninteractive; apt-get update -qq 2>/dev/null || true; apt-get install -y -qq "${pkgs[@]}" ;;
    dnf) dnf install -y -q "${pkgs[@]}" ;;
    yum) yum install -y -q "${pkgs[@]}" ;;
    pacman) pacman -Sy --noconfirm --quiet "${pkgs[@]}" ;;
    apk) apk add --no-cache --quiet "${pkgs[@]}" ;;
    zypper) zypper --non-interactive install -y -q "${pkgs[@]}" ;;
  esac
}

deps_required_pkgs(){
  local backend="${1:-auto}"
  local -a base=(iproute2 ca-certificates openssl curl systemd-tools)
  local -a mapped=()
  local p
  for p in "${base[@]}"; do mapped+=("$(map_pkg "${p}")"); done
  if [[ "${backend}" == "iptables" || "${backend}" == "auto" ]]; then mapped+=("$(map_pkg iptables)"); fi
  if [[ "${backend}" == "nft" || "${backend}" == "auto" ]]; then mapped+=("$(map_pkg nftables)"); fi
  mapped+=("jq")
  printf "%s\n" "${mapped[@]}" | awk '!seen[$0]++'
}

deps_check(){
  local -a need_cmd=(ip openssl curl systemctl)
  local missing=0 c
  for c in "${need_cmd[@]}"; do
    if ! command -v "${c}" >/dev/null 2>&1; then log_w "Missing command: ${c}"; missing=1; else log_ok "Found: ${c}"; fi
  done
  if ! command -v iptables >/dev/null 2>&1 && ! command -v nft >/dev/null 2>&1; then log_w "No firewall tool found (iptables or nft)"; missing=1; fi
  return "${missing}"
}

deps_install(){
  local backend="${1:-auto}" offline="${2:-0}"
  detect_os
  if [[ "${offline}" == "1" ]]; then
    log_w "Offline mode: skipping dependency installation. Install manually:"
    deps_required_pkgs "${backend}" | sed 's/^/  - /'
    return 0
  fi
  mapfile -t pkgs < <(deps_required_pkgs "${backend}")
  echo "Packages to install:"; printf '  - %s\n' "${pkgs[@]}"
  if read_yesno "Install dependencies now?" "y"; then pkg_install "${pkgs[@]}"; fi
}

sha256_text(){
  if command -v sha256sum >/dev/null 2>&1; then printf "%s" "$1" | sha256sum | awk '{print $1}';
  elif command -v shasum >/dev/null 2>&1; then printf "%s" "$1" | shasum -a 256 | awk '{print $1}';
  else python3 - <<'PY'
import hashlib,sys
print(hashlib.sha256(sys.stdin.buffer.read()).hexdigest())
PY
  fi
}

gen_secret(){ command -v openssl >/dev/null 2>&1 && openssl rand -hex 32 || head -c 32 /dev/urandom | xxd -p -c 64; }
gen_token(){ command -v openssl >/dev/null 2>&1 && openssl rand -hex 24 || head -c 24 /dev/urandom | xxd -p -c 48; }

bundle_validate(){
  local dir="$1"
  local -a required=("${dir}/${GATEWAY_BIN}" "${dir}/${AGENT_BIN}" "${dir}/${TOOLS_BIN}" "${dir}/${STEALTHLINK_BIN}" "${dir}/stealthlink-ctl" "${dir}/systemd/${GATEWAY_UNIT}" "${dir}/systemd/${AGENT_UNIT}")
  local f
  for f in "${required[@]}"; do [[ -f "${f}" ]] || return 1; done
  if [[ -f "${dir}/BUNDLE_MANIFEST.json" ]] && command -v python3 >/dev/null 2>&1; then
    python3 - "${dir}/BUNDLE_MANIFEST.json" <<'PY'
import json,sys
m=json.load(open(sys.argv[1],'r',encoding='utf-8'))
for k in ('version','commit','build_time_utc'):
    if not m.get(k): raise SystemExit(2)
PY
  fi
  return 0
}

bundle_resolve(){
  local bundle_path="${1:-}"
  local script_dir
  script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
  if [[ -z "${bundle_path}" ]]; then
    if bundle_validate "${script_dir}"; then BUNDLE_ROOT="${script_dir}"; return 0; fi
    if bundle_validate "${script_dir}/.."; then BUNDLE_ROOT="${script_dir}/.."; return 0; fi
    for z in ./stealthlink-*.zip ./dist/stealthlink-*.zip "${script_dir}/.."/*.zip; do [[ -f "${z}" ]] || continue; bundle_path="${z}"; break; done
    [[ -z "${bundle_path}" ]] && die "Could not auto-detect bundle. Use: --bundle <path>"
  fi
  if [[ -d "${bundle_path}" ]]; then
    if bundle_validate "${bundle_path}"; then BUNDLE_ROOT="${bundle_path}"; return 0; fi
    local cand
    while IFS= read -r cand; do if bundle_validate "${cand}"; then BUNDLE_ROOT="${cand}"; return 0; fi; done < <(find "${bundle_path}" -mindepth 1 -maxdepth 2 -type d 2>/dev/null)
    die "Invalid bundle directory: ${bundle_path}"
  fi
  if [[ -f "${bundle_path}" && "${bundle_path}" == *.zip ]]; then
    TMP_DIR="$(mktemp -d)"
    if command -v unzip >/dev/null 2>&1; then unzip -q "${bundle_path}" -d "${TMP_DIR}";
    elif command -v python3 >/dev/null 2>&1; then
      python3 - "${bundle_path}" "${TMP_DIR}" <<'PY'
import zipfile,sys
with zipfile.ZipFile(sys.argv[1],'r') as zf: zf.extractall(sys.argv[2])
PY
    else die "Need unzip or python3 to extract ZIP"; fi
    if bundle_validate "${TMP_DIR}"; then BUNDLE_ROOT="${TMP_DIR}"; return 0; fi
    local cand
    while IFS= read -r cand; do if bundle_validate "${cand}"; then BUNDLE_ROOT="${cand}"; return 0; fi; done < <(find "${TMP_DIR}" -mindepth 1 -maxdepth 2 -type d 2>/dev/null)
    die "Invalid bundle: ${bundle_path}"
  fi
  die "Bundle not found: ${bundle_path}"
}

bundle_resolve_root(){ bundle_resolve "$1"; }

install_binaries(){
  local bundle_path="${1:-}" role="${2:-both}" offline="${3:-0}"
  bundle_resolve "${bundle_path}"
  ensure_dirs
  deps_install auto "${offline}"
  local root="${BUNDLE_ROOT}" b
  local -a bins=("${GATEWAY_BIN}" "${AGENT_BIN}" "${TOOLS_BIN}" "${STEALTHLINK_BIN}" "stealthlink-ctl")
  for b in "${bins[@]}"; do install -m 0755 "${root}/${b}" "${BIN_DIR}/${b}"; done
  install -m 0644 "${root}/systemd/${GATEWAY_UNIT}" "${SYSTEMD_DIR}/${GATEWAY_UNIT}"
  install -m 0644 "${root}/systemd/${AGENT_UNIT}" "${SYSTEMD_DIR}/${AGENT_UNIT}"
  if [[ -d "${root}/examples" ]]; then mkdir -p "${LIB_DIR}/examples"; cp -r "${root}/examples/." "${LIB_DIR}/examples/" 2>/dev/null || true; fi
  if [[ -d "${root}/tools" ]]; then mkdir -p "${LIB_DIR}/tools"; cp -r "${root}/tools/." "${LIB_DIR}/tools/" 2>/dev/null || true; fi
  systemctl daemon-reload 2>/dev/null || true
  cat >"${STATE_DIR}/install-receipt.json" <<JSON
{
  "installed_at": "$(date -u '+%Y-%m-%dT%H:%M:%SZ')",
  "bundle": "${bundle_path:-auto}",
  "role": "${role}",
  "offline": ${offline}
}
JSON
  chmod 0600 "${STATE_DIR}/install-receipt.json" 2>/dev/null || true
  log_ok "Installed binaries and units from ${root}"
}

write_yaml(){ local path="$1" content="$2"; umask 077; mkdir -p "$(dirname "${path}")"; printf "%s\n" "${content}" >"${path}"; chmod 0600 "${path}" 2>/dev/null || true; }

wizard_variant(){
  ui_print ""
  ui_print "${C_BOLD}Select Variant${C_RESET}"
  ui_print "  1) 4a  2) 4b  3) 4c  4) 4d  5) 4e  6) custom"
  case "$(read_input "Select" "4")" in 1) echo "4a";; 2) echo "4b";; 3) echo "4c";; 4) echo "4d";; 5) echo "4e";; *) echo "custom";; esac
}

wizard_carrier(){
  local variant="$1"
  case "${variant}" in
    4a) echo "xhttp";; 4b) echo "rawtcp";; 4c) echo "xhttp";; 4d) echo "quic";; 4e) echo "trusttunnel";;
    custom)
      ui_print "Carrier: 1)quic 2)xhttp 3)rawtcp 4)faketcp 5)masque 6)trusttunnel"
      case "$(read_input "Carrier" "1")" in 2) echo "xhttp";; 3) echo "rawtcp";; 4) echo "faketcp";; 5) echo "masque";; 6) echo "trusttunnel";; *) echo "quic";; esac ;;
    *) echo "quic" ;;
  esac
}

wizard_connectivity(){ ui_print "Model: 1) Agent dials Gateway  2) Reverse-connect"; [[ "$(read_input "Select" "1")" == "2" ]] && echo reverse || echo normal; }

wizard_overlays(){
  ui_print "Overlays (space-separated numbers): 1)ech 2)reality 3)shadowtls 4)tlsfrag 5)obfs4 6)awg 7)none"
  local s o=""; s=$(read_input "Select" "7")
  for n in ${s}; do case "$n" in 1)o+="ech ";;2)o+="reality ";;3)o+="shadowtls ";;4)o+="tlsfrag ";;5)o+="obfs4 ";;6)o+="awg ";; esac; done
  printf "%s" "${o}"
}

generate_behavior_yaml(){ local overlays="$1" yaml=""; local o; for o in ${overlays}; do yaml+="      ${o}:\n        enabled: true\n"; done; printf "%s" "${yaml}"; }

wizard_pair(){
  local mode="${1:-pair}"
  ensure_dirs
  local variant carrier connectivity shared_key gw_listen gw_addr agent_id iface mtu gw_vip agent_vip gw_peer agent_peer
  variant="$(wizard_variant)"
  carrier="$(wizard_carrier "${variant}")"
  connectivity="$(wizard_connectivity)"
  if read_yesno "Generate new shared key?" "y"; then shared_key="$(gen_secret)"; else shared_key="$(read_password "Shared key")"; fi
  gw_listen="$(read_input "Gateway listen" "0.0.0.0:8443")"
  gw_addr="$(read_input "Gateway public address" "127.0.0.1:8443")"
  agent_id="$(read_input "Agent ID" "agent-1")"
  iface="$(read_input "TUN interface" "sl0")"
  mtu="$(read_input "MTU" "1400")"
  gw_vip="$(read_input "Gateway virtual IP (CIDR)" "10.77.0.1/30")"
  agent_vip="$(read_input "Agent virtual IP (CIDR)" "10.77.0.2/30")"
  gw_peer="${agent_vip%%/*}"; agent_peer="${gw_vip%%/*}"

  local reverse_enabled="false" reverse_auth=""
  if [[ "${connectivity}" == "reverse" ]]; then reverse_enabled="true"; reverse_auth="$(gen_token)"; fi
  local warp_enabled="false" warp_required="true"
  if read_yesno "Enable WARP underlay?" "n"; then warp_enabled="true"; read_yesno "WARP required/fail-closed?" "y" || warp_required="false"; fi

  local overlays="" behavior_yaml=""
  if read_yesno "Configure overlays/behaviors?" "n"; then overlays="$(wizard_overlays)"; fi
  [[ -n "${overlays}" ]] && behavior_yaml="$(generate_behavior_yaml "${overlays}")"

  local transport_yaml="transport:\n  type: uqsp\n  uqsp:\n    carrier:\n      type: ${carrier}\n"
  [[ -n "${behavior_yaml}" ]] && transport_yaml+="    behaviors:\n${behavior_yaml}"
  [[ "${reverse_enabled}" == "true" ]] && transport_yaml+="    reverse:\n      enabled: true\n      auth_token: \"${reverse_auth}\"\n"

  local dialer_yaml="" warp_yaml=""
  if [[ "${warp_enabled}" == "true" ]]; then
    dialer_yaml="transport:\n  dialer: warp\n  warp_dialer:\n    mode: consumer\n    engine: builtin\n    required: ${warp_required}\n"
    warp_yaml="warp:\n  enabled: true\n  mode: builtin\n  endpoint: \"engage.cloudflareclient.com:2408\"\n  routing_mode: vpn_only\n  keepalive: 25s\n"
  fi

  local gw_cfg="# StealthLink Gateway\nrole: gateway\nvariant: \"${variant}\"\ngateway:\n  listen: \"${gw_listen}\"\n${transport_yaml}${dialer_yaml}security:\n  shared_key: \"${shared_key}\"\nvpn:\n  enabled: true\n  mode: tun\n  name: \"${iface}\"\n  interface_ip: \"${gw_vip}\"\n  peer_ip: \"${gw_peer}\"\n  mtu: ${mtu}\nmetrics:\n  listen: \"127.0.0.1:9091\"\n${warp_yaml}"
  local agent_cfg="# StealthLink Agent\nrole: agent\nvariant: \"${variant}\"\nagent:\n  id: \"${agent_id}\"\n  gateway_addr: \"${gw_addr}\"\n  reconnect_backoff: \"3s\"\n${transport_yaml}${dialer_yaml}security:\n  shared_key: \"${shared_key}\"\nvpn:\n  enabled: true\n  mode: tun\n  name: \"${iface}\"\n  interface_ip: \"${agent_vip}\"\n  peer_ip: \"${agent_peer}\"\n  mtu: ${mtu}\nmetrics:\n  listen: \"127.0.0.1:9092\"\n${warp_yaml}"

  local key_hash; key_hash="$(sha256_text "${shared_key}")"
  case "${mode}" in gateway) write_yaml "${GATEWAY_CFG}" "${gw_cfg}"; log_ok "Wrote ${GATEWAY_CFG}";; agent) write_yaml "${AGENT_CFG}" "${agent_cfg}"; log_ok "Wrote ${AGENT_CFG}";; *) write_yaml "${GATEWAY_CFG}" "${gw_cfg}"; write_yaml "${AGENT_CFG}" "${agent_cfg}"; log_ok "Wrote ${GATEWAY_CFG} and ${AGENT_CFG}";; esac

  cat >"${LIB_DIR}/pairing.txt" <<TXT
StealthLink Pairing Information
Generated: $(date -u '+%Y-%m-%dT%H:%M:%SZ')

Variant: ${variant}
Carrier: ${carrier}
Connectivity: ${connectivity}
Shared Key SHA256: ${key_hash}

Gateway:
  Listen: ${gw_listen}
  Virtual IP: ${gw_vip} (peer ${gw_peer})
  Config: ${GATEWAY_CFG}

Agent:
  ID: ${agent_id}
  Gateway Address: ${gw_addr}
  Virtual IP: ${agent_vip} (peer ${agent_peer})
  Config: ${AGENT_CFG}

WARP: ${warp_enabled} (required: ${warp_required})

Apply on peer:
  1) Copy matching config to peer host.
  2) Run network setup (ip_forward/rp_filter) on both peers when routing traffic.
  3) Run firewall apply on both peers.
  4) Start services:
     - stealthlink-ctl service gateway start
     - stealthlink-ctl service agent start
TXT
  chmod 0600 "${LIB_DIR}/pairing.txt" 2>/dev/null || true
  log_ok "Pairing note: ${LIB_DIR}/pairing.txt"
}

network_setup(){
  ensure_dirs
  local ipf rpa rpd
  ipf=$(sysctl -n net.ipv4.ip_forward 2>/dev/null || echo "0")
  rpa=$(sysctl -n net.ipv4.conf.all.rp_filter 2>/dev/null || echo "1")
  rpd=$(sysctl -n net.ipv4.conf.default.rp_filter 2>/dev/null || echo "1")
  echo "Current: ip_forward=${ipf}, rp_filter(all)=${rpa}, rp_filter(default)=${rpd}"
  if read_yesno "Apply recommended VPN routing sysctl values now?" "y"; then
    cat >/etc/sysctl.d/99-stealthlink-network.conf <<'SYS'
net.ipv4.ip_forward=1
net.ipv6.conf.all.forwarding=1
net.ipv4.conf.all.rp_filter=2
net.ipv4.conf.default.rp_filter=2
SYS
    sysctl --system >/dev/null 2>&1 || true
    log_ok "Applied /etc/sysctl.d/99-stealthlink-network.conf"
  else
    log_i "Skipped. Guidance: set ip_forward=1 and rp_filter=2 for asymmetric routing."
  fi
}

apply_sysctl_fallback(){
  local profile="${1:-balanced}" sysctl_file="/etc/sysctl.d/99-stealthlink.conf"
  [[ -f "${sysctl_file}" ]] && cp -f "${sysctl_file}" "${BACKUP_DIR}/99-stealthlink.conf.$(date +%s).bak"
  case "${profile}" in
    latency)
      cat >"${sysctl_file}" <<'EOF_LAT'
net.core.somaxconn=8192
net.core.netdev_max_backlog=8192
net.core.rmem_max=16777216
net.core.wmem_max=16777216
net.ipv4.tcp_fastopen=3
net.ipv4.tcp_mtu_probing=1
net.ipv4.tcp_congestion_control=bbr
net.core.default_qdisc=fq
EOF_LAT
      ;;
    throughput)
      cat >"${sysctl_file}" <<'EOF_TP'
net.core.somaxconn=65536
net.core.netdev_max_backlog=65536
net.core.rmem_max=67108864
net.core.wmem_max=67108864
net.ipv4.tcp_fastopen=3
net.ipv4.tcp_mtu_probing=1
net.ipv4.tcp_congestion_control=bbr
net.core.default_qdisc=fq
EOF_TP
      ;;
    *)
      cat >"${sysctl_file}" <<'EOF_BAL'
net.core.somaxconn=4096
net.core.netdev_max_backlog=4096
net.ipv4.tcp_fastopen=3
net.ipv4.tcp_mtu_probing=1
net.ipv4.tcp_congestion_control=bbr
net.core.default_qdisc=fq
EOF_BAL
      ;;
  esac
  sysctl --system >/dev/null 2>&1 || sysctl -p "${sysctl_file}" >/dev/null 2>&1 || true
  log_ok "Applied fallback sysctl profile: ${profile}"
}

apply_tuning(){
  local profile="${1:-balanced}" out="" token=""
  ensure_dirs
  if [[ -x "${BIN_DIR}/${TOOLS_BIN}" ]]; then
    if out="$(${BIN_DIR}/${TOOLS_BIN} host-optimize "${profile}" --apply 2>&1)"; then
      token="$(printf '%s\n' "${out}" | grep -Eo 'token[=: ]+[A-Za-z0-9._-]+' | tail -1 | sed -E 's/.*[=: ]+//')"
      if [[ -n "${token}" ]]; then printf "%s\n" "${token}" >"${HOSTOPT_TOKEN_FILE}"; chmod 0600 "${HOSTOPT_TOKEN_FILE}" || true; fi
      log_ok "Applied host-optimize profile: ${profile}"
      [[ -n "${token}" ]] && log_ok "Rollback token stored: ${HOSTOPT_TOKEN_FILE}"
      return 0
    fi
    log_w "host-optimize failed; falling back to conservative sysctl"
  fi
  apply_sysctl_fallback "${profile}"
}

rollback_tuning(){
  if [[ -f "${HOSTOPT_TOKEN_FILE}" && -x "${BIN_DIR}/${TOOLS_BIN}" ]]; then
    local token; token="$(cat "${HOSTOPT_TOKEN_FILE}")"
    if "${BIN_DIR}/${TOOLS_BIN}" host-optimize rollback --token "${token}"; then log_ok "Rollback complete via host-optimize token"; return 0; fi
  fi
  local bak; bak=$(ls -t "${BACKUP_DIR}"/99-stealthlink.conf.*.bak 2>/dev/null | head -1 || true)
  [[ -n "${bak}" ]] || die "No rollback token or backup found"
  cp "${bak}" /etc/sysctl.d/99-stealthlink.conf
  sysctl --system >/dev/null 2>&1 || true
  log_ok "Restored fallback sysctl backup: ${bak}"
}

extract_port(){ local cfg="$1" p; p=$(grep -Eo 'listen:[[:space:]]*"?[0-9a-zA-Z\.:_-]+:[0-9]{2,5}"?' "${cfg}" 2>/dev/null | head -1 | grep -Eo '[0-9]{2,5}$' || true); [[ -n "${p}" ]] && echo "${p}" || echo "8443"; }
extract_carrier(){ local cfg="$1"; grep -Eo 'type:[[:space:]]*(rawtcp|faketcp|quic|xhttp|masque|trusttunnel)' "${cfg}" 2>/dev/null | head -1 | awk -F: '{gsub(/ /,"",$2);print $2}'; }

detect_firewall_backend(){ if command -v nft >/dev/null 2>&1 && nft list ruleset >/dev/null 2>&1; then echo nft; elif command -v iptables >/dev/null 2>&1; then echo iptables; else echo none; fi; }

apply_firewall_role(){
  local role="$1" backend="${2:-auto}" cfg
  case "${role}" in gateway) cfg="${GATEWAY_CFG}";; agent) cfg="${AGENT_CFG}";; *) die "Invalid role: ${role}";; esac
  [[ -f "${cfg}" ]] || die "Config not found: ${cfg}"
  [[ "${backend}" == "auto" ]] && backend="$(detect_firewall_backend)"
  [[ "${backend}" == "none" ]] && die "No firewall backend available"

  local port carrier raw_hardening="false"
  port="$(extract_port "${cfg}")"; carrier="$(extract_carrier "${cfg}")"
  [[ "${carrier}" == "rawtcp" || "${carrier}" == "faketcp" ]] && raw_hardening="true"

  if [[ "${backend}" == "nft" ]]; then
    nft list table inet stealthlink >/dev/null 2>&1 || nft add table inet stealthlink
    nft list chain inet stealthlink input >/dev/null 2>&1 || nft add chain inet stealthlink input '{ type filter hook input priority 0; policy accept; }'
    nft list chain inet stealthlink output >/dev/null 2>&1 || nft add chain inet stealthlink output '{ type filter hook output priority 0; policy accept; }'
    nft list chain inet stealthlink input | grep -q "tcp dport ${port} accept" || nft add rule inet stealthlink input tcp dport "${port}" accept
    nft list chain inet stealthlink input | grep -q "udp dport ${port} accept" || nft add rule inet stealthlink input udp dport "${port}" accept
    if [[ "${raw_hardening}" == "true" ]]; then
      nft list table ip stealthlink_raw >/dev/null 2>&1 || nft add table ip stealthlink_raw
      nft list chain ip stealthlink_raw prerouting >/dev/null 2>&1 || nft add chain ip stealthlink_raw prerouting '{ type filter hook prerouting priority -300; policy accept; }'
      nft list chain ip stealthlink_raw output >/dev/null 2>&1 || nft add chain ip stealthlink_raw output '{ type filter hook output priority 0; policy accept; }'
      nft list chain ip stealthlink_raw prerouting | grep -q "tcp dport ${port} notrack" || nft add rule ip stealthlink_raw prerouting tcp dport "${port}" notrack
      nft list chain ip stealthlink_raw output | grep -q "tcp sport ${port} tcp flags rst / rst drop" || nft add rule ip stealthlink_raw output tcp sport "${port}" tcp flags rst / rst drop
    fi
  else
    iptables -C INPUT -p tcp --dport "${port}" -j ACCEPT 2>/dev/null || iptables -I INPUT -p tcp --dport "${port}" -j ACCEPT
    iptables -C INPUT -p udp --dport "${port}" -j ACCEPT 2>/dev/null || iptables -I INPUT -p udp --dport "${port}" -j ACCEPT
    if [[ "${raw_hardening}" == "true" ]]; then
      iptables -t raw -C PREROUTING -p tcp --dport "${port}" -j CT --notrack 2>/dev/null || iptables -t raw -I PREROUTING -p tcp --dport "${port}" -j CT --notrack || true
      iptables -C OUTPUT -p tcp --sport "${port}" --tcp-flags RST RST -j DROP 2>/dev/null || iptables -I OUTPUT -p tcp --sport "${port}" --tcp-flags RST RST -j DROP
    fi
    command -v netfilter-persistent >/dev/null 2>&1 && netfilter-persistent save >/dev/null 2>&1 || true
  fi

  mkdir -p "${FIREWALL_STATE_DIR}"
  cat >"${FIREWALL_STATE_FILE}" <<JSON
{
  "backend": "${backend}",
  "role": "${role}",
  "port": ${port},
  "carrier": "${carrier}",
  "raw_hardening": ${raw_hardening},
  "applied_at": "$(date -u '+%Y-%m-%dT%H:%M:%SZ')"
}
JSON
  log_ok "Firewall applied (${backend}) for ${role} on port ${port}"
}

remove_firewall_role(){
  local role="${1:-}" backend="" port="" raw="false"
  if [[ -f "${FIREWALL_STATE_FILE}" ]]; then
    backend="$(python3 - <<PY
import json
s=json.load(open('${FIREWALL_STATE_FILE}'))
print(s.get('backend',''))
PY
)"
    port="$(python3 - <<PY
import json
s=json.load(open('${FIREWALL_STATE_FILE}'))
print(s.get('port',''))
PY
)"
    raw="$(python3 - <<PY
import json
s=json.load(open('${FIREWALL_STATE_FILE}'))
print(str(s.get('raw_hardening',False)).lower())
PY
)"
  fi
  if [[ -n "${role}" ]]; then
    local cfg; cfg=$([[ "${role}" == "gateway" ]] && echo "${GATEWAY_CFG}" || echo "${AGENT_CFG}")
    [[ -f "${cfg}" ]] && port="$(extract_port "${cfg}")"
  fi
  [[ -z "${port}" ]] && { log_w "No firewall state found"; return 0; }
  [[ -z "${backend}" ]] && backend="$(detect_firewall_backend)"

  if [[ "${backend}" == "nft" ]]; then
    nft delete rule inet stealthlink input tcp dport "${port}" accept 2>/dev/null || true
    nft delete rule inet stealthlink input udp dport "${port}" accept 2>/dev/null || true
    if [[ "${raw}" == "true" ]]; then
      nft delete rule ip stealthlink_raw prerouting tcp dport "${port}" notrack 2>/dev/null || true
      nft delete rule ip stealthlink_raw output tcp sport "${port}" tcp flags rst / rst drop 2>/dev/null || true
    fi
  else
    iptables -D INPUT -p tcp --dport "${port}" -j ACCEPT 2>/dev/null || true
    iptables -D INPUT -p udp --dport "${port}" -j ACCEPT 2>/dev/null || true
    iptables -t raw -D PREROUTING -p tcp --dport "${port}" -j CT --notrack 2>/dev/null || true
    iptables -D OUTPUT -p tcp --sport "${port}" --tcp-flags RST RST -j DROP 2>/dev/null || true
    command -v netfilter-persistent >/dev/null 2>&1 && netfilter-persistent save >/dev/null 2>&1 || true
  fi
  rm -f "${FIREWALL_STATE_FILE}"
  log_ok "Firewall rules removed"
}

firewall_hooks(){
  local action="$1" role unit
  for role in gateway agent; do
    unit=$([[ "${role}" == "gateway" ]] && echo "${GATEWAY_UNIT}" || echo "${AGENT_UNIT}")
    local dropin_dir="${SYSTEMD_DIR}/${unit}.d" dropin_file="${dropin_dir}/firewall.conf"
    if [[ "${action}" == "enable" ]]; then
      mkdir -p "${dropin_dir}"
      cat >"${dropin_file}" <<DROP
[Service]
ExecStartPre=${BIN_DIR}/stealthlink-ctl firewall apply ${role}
ExecStopPost=${BIN_DIR}/stealthlink-ctl firewall remove ${role}
DROP
      log_ok "Enabled firewall hooks for ${unit}"
    else
      rm -f "${dropin_file}"; rmdir "${dropin_dir}" 2>/dev/null || true; log_ok "Disabled firewall hooks for ${unit}"
    fi
  done
  systemctl daemon-reload >/dev/null 2>&1 || true
}

warp_set_role(){
  local role="$1" enabled="$2" required="$3" cfg
  case "${role}" in gateway) cfg="${GATEWAY_CFG}";; agent) cfg="${AGENT_CFG}";; *) die "Invalid role: ${role}";; esac
  [[ -f "${cfg}" ]] || die "Config not found: ${cfg}"
  python3 - "${cfg}" "${enabled}" "${required}" <<'PY'
import re,sys
p,enabled,required=sys.argv[1],sys.argv[2],sys.argv[3]
text=open(p,'r',encoding='utf-8').read()
text=re.sub(r'(?ms)^warp:\n(?:^[ \t].*\n)*','',text)
if re.search(r'(?ms)^\s*warp_dialer:\n(?:^\s+.*\n)*', text):
    text=re.sub(r'(?m)^\s*required:\s*.*$', f'    required: {required}', text, count=1)
else:
    text += '\ntransport:\n  dialer: warp\n  warp_dialer:\n    mode: consumer\n    engine: builtin\n    required: %s\n' % required
text += '\nwarp:\n  enabled: %s\n  mode: builtin\n  endpoint: "engage.cloudflareclient.com:2408"\n  routing_mode: vpn_only\n  keepalive: 25s\n' % enabled
open(p,'w',encoding='utf-8').write(text)
PY
  log_ok "Updated ${cfg}: warp enabled=${enabled}, required=${required}"
}

warp_status(){
  local cfg role
  for role in gateway agent; do
    cfg=$([[ "${role}" == "gateway" ]] && echo "${GATEWAY_CFG}" || echo "${AGENT_CFG}")
    if [[ -f "${cfg}" ]]; then
      echo "${role}:"
      grep -E 'warp:|enabled:|required:|dialer:' "${cfg}" | sed 's/^/  /' | head -20 || true
    else
      echo "${role}: config missing (${cfg})"
    fi
  done
}

warp_register(){
  local role="${1:-gateway}" cfg
  cfg=$([[ "${role}" == "agent" ]] && echo "${AGENT_CFG}" || echo "${GATEWAY_CFG}")
  [[ -f "${cfg}" ]] || die "Config not found: ${cfg}"
  [[ -x "${BIN_DIR}/${TOOLS_BIN}" ]] || die "${TOOLS_BIN} not found. Run: ${BIN_DIR}/${TOOLS_BIN} warp register --config ${cfg}"
  "${BIN_DIR}/${TOOLS_BIN}" warp register --config "${cfg}"
}

validate_config(){
  local role="$1" bin cfg
  case "${role}" in gateway) bin="${BIN_DIR}/${GATEWAY_BIN}"; cfg="${GATEWAY_CFG}";; agent) bin="${BIN_DIR}/${AGENT_BIN}"; cfg="${AGENT_CFG}";; *) die "Invalid role: ${role}";; esac
  [[ -x "${bin}" ]] || die "Binary not found: ${bin}"
  [[ -f "${cfg}" ]] || die "Config not found: ${cfg}"
  "${bin}" -config "${cfg}" -validate
  log_ok "Config valid: ${role}"
}

service_op(){
  local role="$1" op="$2" unit
  case "${role}" in gateway) unit="${GATEWAY_UNIT}";; agent) unit="${AGENT_UNIT}";; *) die "Invalid role: ${role}";; esac
  case "${op}" in enable|disable|start|stop|restart|status) systemctl "${op}" "${unit}" ;;
    logs) journalctl -u "${unit}" -n 100 --no-pager ;;
    *) die "Invalid service operation: ${op}" ;;
  esac
}

monitor_menu(){
  while true; do
    local act
    act=$(select_menu "Monitoring & Bench" "metrics_gateway" "Fetch gateway metrics" "metrics_agent" "Fetch agent metrics" "status" "Show service status" "ping" "Ping peer virtual IP" "bench" "Run bench" "live_stress" "Run live-stress" "back" "Back")
    case "${act}" in
      metrics_gateway|metrics_agent)
        local cfg m
        cfg=$([[ "${act}" == "metrics_gateway" ]] && echo "${GATEWAY_CFG}" || echo "${AGENT_CFG}")
        [[ -f "${cfg}" ]] || { log_w "Missing config: ${cfg}"; press_enter; continue; }
        m=$(grep -E 'listen:[[:space:]]*"?[0-9\.]+:[0-9]+"?' "${cfg}" | tail -1 | awk -F'"' '{print $2}')
        [[ -z "${m}" ]] && m="127.0.0.1:9091"
        curl -fsS "http://${m}/metrics" | head -40 || log_w "Unable to fetch metrics from ${m}"
        press_enter ;;
      status) systemctl status "${GATEWAY_UNIT}" "${AGENT_UNIT}" --no-pager || true; press_enter ;;
      ping)
        local peer
        peer=$(grep -E 'peer_ip:' "${AGENT_CFG}" 2>/dev/null | head -1 | awk -F'"' '{print $2}')
        [[ -z "${peer}" ]] && peer=$(grep -E 'peer_ip:' "${GATEWAY_CFG}" 2>/dev/null | head -1 | awk -F'"' '{print $2}')
        [[ -z "${peer}" ]] && { log_w "No peer_ip found"; press_enter; continue; }
        ping -c 4 "${peer}" || true
        press_enter ;;
      bench)
        [[ -x "${BIN_DIR}/${TOOLS_BIN}" ]] && "${BIN_DIR}/${TOOLS_BIN}" bench || log_w "${TOOLS_BIN} bench unavailable"
        press_enter ;;
      live_stress)
        [[ -x "${BIN_DIR}/${TOOLS_BIN}" ]] && "${BIN_DIR}/${TOOLS_BIN}" live-stress || log_w "${TOOLS_BIN} live-stress unavailable"
        press_enter ;;
      back) return 0 ;;
    esac
  done
}

uninstall(){
  local purge="${1:-0}"
  if [[ "${purge}" == "1" ]]; then read_yesno "Purge ALL (binaries, configs, state)?" "n" || return 0; else read_yesno "Uninstall binaries (keep config/state)?" "n" || return 0; fi
  systemctl disable --now "${GATEWAY_UNIT}" "${AGENT_UNIT}" >/dev/null 2>&1 || true
  rm -f "${SYSTEMD_DIR}/${GATEWAY_UNIT}" "${SYSTEMD_DIR}/${AGENT_UNIT}" 2>/dev/null || true
  systemctl daemon-reload >/dev/null 2>&1 || true
  rm -f "${BIN_DIR}/${GATEWAY_BIN}" "${BIN_DIR}/${AGENT_BIN}" "${BIN_DIR}/${TOOLS_BIN}" "${BIN_DIR}/${STEALTHLINK_BIN}" "${BIN_DIR}/stealthlink-ctl" 2>/dev/null || true
  [[ "${purge}" == "1" ]] && rm -rf "${ETC_DIR}" "${LIB_DIR}" "${LOG_DIR}" 2>/dev/null || true
  log_ok "Uninstall complete"
}

main_menu(){
  while true; do
    print_banner
    echo -e "${C_BOLD}Main Menu${C_RESET}"
    echo "  1) Install / Upgrade (local ZIP or directory)"
    echo "  2) Configure Wizard (Gateway / Agent / Generate both)"
    echo "  3) Network & VPN Setup"
    echo "  4) Firewall"
    echo "  5) WARP Underlay"
    echo "  6) Service Control"
    echo "  7) Monitoring & Bench"
    echo "  8) Uninstall / Purge"
    echo "  0) Exit"
    local sel
    sel=$(read_input "Select" "1")
    case "${sel}" in
      1)
        local bundle role offline
        bundle=$(read_input "Bundle path (ZIP or directory)" "")
        role=$(select_menu "Role" "gateway" "Gateway" "agent" "Agent" "both" "Both")
        offline=0; read_yesno "Offline mode?" "n" && offline=1
        install_binaries "${bundle}" "${role}" "${offline}"; press_enter ;;
      2)
        local mode
        mode=$(select_menu "Wizard target" "gateway" "Generate gateway.yaml" "agent" "Generate agent.yaml" "pair" "Generate both")
        wizard_pair "${mode}"; press_enter ;;
      3) network_setup; press_enter ;;
      4)
        local fact
        fact=$(select_menu "Firewall" "apply_gateway" "Apply for gateway" "apply_agent" "Apply for agent" "remove_gateway" "Remove for gateway" "remove_agent" "Remove for agent" "hooks_enable" "Enable systemd hooks" "hooks_disable" "Disable systemd hooks")
        case "${fact}" in
          apply_gateway) apply_firewall_role gateway auto ;;
          apply_agent) apply_firewall_role agent auto ;;
          remove_gateway) remove_firewall_role gateway ;;
          remove_agent) remove_firewall_role agent ;;
          hooks_enable) firewall_hooks enable ;;
          hooks_disable) firewall_hooks disable ;;
        esac
        press_enter ;;
      5)
        local wact wrole req
        wact=$(select_menu "WARP" "enable" "Enable" "disable" "Disable" "register" "Register" "status" "Status")
        case "${wact}" in
          enable)
            wrole=$(select_menu "Role" "gateway" "Gateway" "agent" "Agent" "both" "Both")
            req=true; read_yesno "Require WARP (fail-closed)?" "y" || req=false
            if [[ "${wrole}" == "both" ]]; then warp_set_role gateway true "${req}"; warp_set_role agent true "${req}"; else warp_set_role "${wrole}" true "${req}"; fi ;;
          disable)
            wrole=$(select_menu "Role" "gateway" "Gateway" "agent" "Agent" "both" "Both")
            if [[ "${wrole}" == "both" ]]; then warp_set_role gateway false false; warp_set_role agent false false; else warp_set_role "${wrole}" false false; fi ;;
          register)
            wrole=$(select_menu "Role" "gateway" "Gateway" "agent" "Agent")
            warp_register "${wrole}" ;;
          status) warp_status ;;
        esac
        press_enter ;;
      6)
        local role op
        role=$(select_menu "Service" "gateway" "Gateway" "agent" "Agent")
        op=$(select_menu "Operation" "enable" "Enable" "start" "Start" "restart" "Restart" "status" "Status" "logs" "Logs" "stop" "Stop" "disable" "Disable")
        service_op "${role}" "${op}"; press_enter ;;
      7) monitor_menu ;;
      8)
        local act
        act=$(select_menu "Uninstall" "uninstall" "Remove binaries (keep config)" "purge" "Remove everything")
        uninstall "$([[ "${act}" == "purge" ]] && echo 1 || echo 0)"; press_enter ;;
      0|q|exit) echo "Goodbye"; return 0 ;;
      *) log_w "Invalid selection"; press_enter ;;
    esac
  done
}

usage(){
  cat <<'USAGE'
stealthlink-ctl v5.0.0

Usage:
  stealthlink-ctl
  stealthlink-ctl install [--bundle PATH] [--role gateway|agent|both] [--offline]
  stealthlink-ctl wizard gateway|agent|pair
  stealthlink-ctl deps install|check [--offline]
  stealthlink-ctl tuning apply [balanced|latency|throughput]
  stealthlink-ctl tuning rollback
  stealthlink-ctl firewall apply|remove [gateway|agent] [--backend auto|nft|iptables]
  stealthlink-ctl firewall hooks enable|disable
  stealthlink-ctl warp enable|disable|register|status [gateway|agent|both] [--required true|false]
  stealthlink-ctl service <gateway|agent> <start|stop|restart|enable|disable|status|logs>
  stealthlink-ctl validate <gateway|agent>
  stealthlink-ctl network setup
  stealthlink-ctl monitor
  stealthlink-ctl uninstall [--purge]
  stealthlink-ctl secret
USAGE
}

main(){
  local cmd="${1:-}"
  case "${cmd}" in
    ""|setup|wizard|monitor|network) reattach_tty "$@" ;;
  esac
  case "${cmd}" in
    "")
      require_root "$@"
      main_menu
      ;;
    -h|--help|help) usage ;;
    install)
      shift
      require_root install
      local bundle="" role="both" offline=0
      while [[ $# -gt 0 ]]; do
        case "$1" in
          --bundle) bundle="${2:-}"; shift 2 ;;
          --role) role="${2:-both}"; shift 2 ;;
          --offline) offline=1; shift ;;
          *) shift ;;
        esac
      done
      install_binaries "${bundle}" "${role}" "${offline}" ;;
    wizard)
      shift
      require_root wizard
      wizard_pair "${1:-pair}" ;;
    deps)
      shift
      require_root deps
      case "${1:-}" in
        check) deps_check || true ;;
        install) local offline=0; [[ "${2:-}" == "--offline" ]] && offline=1; deps_install auto "${offline}" ;;
        *) die "Usage: deps install|check" ;;
      esac ;;
    tuning)
      shift
      require_root tuning
      case "${1:-}" in
        apply) apply_tuning "${2:-balanced}" ;;
        rollback) rollback_tuning ;;
        *) die "Usage: tuning apply <profile>|rollback" ;;
      esac ;;
    firewall)
      shift
      require_root firewall
      if [[ "${1:-}" == "hooks" ]]; then
        case "${2:-}" in enable|disable) firewall_hooks "${2}" ;; *) die "Usage: firewall hooks enable|disable" ;; esac
      else
        local action="${1:-}" role="gateway" backend="auto"
        shift 1 2>/dev/null || true
        if [[ -n "${1:-}" && "${1}" != --* ]]; then role="${1}"; shift; fi
        while [[ $# -gt 0 ]]; do
          case "$1" in --backend) backend="${2:-auto}"; shift 2 ;; *) shift ;; esac
        done
        case "${action}" in
          apply) apply_firewall_role "${role}" "${backend}" ;;
          remove) remove_firewall_role "${role}" ;;
          *) die "Usage: firewall apply|remove [gateway|agent] [--backend auto|nft|iptables]" ;;
        esac
      fi ;;
    warp)
      shift
      require_root warp
      local action="${1:-status}" role="gateway" required="true"
      shift 1 2>/dev/null || true
      if [[ -n "${1:-}" && "${1}" != --* ]]; then role="${1}"; shift; fi
      while [[ $# -gt 0 ]]; do case "$1" in --required) required="${2:-true}"; shift 2 ;; *) shift ;; esac; done
      case "${action}" in
        enable) [[ "${role}" == "both" ]] && { warp_set_role gateway true "${required}"; warp_set_role agent true "${required}"; } || warp_set_role "${role}" true "${required}" ;;
        disable) [[ "${role}" == "both" ]] && { warp_set_role gateway false false; warp_set_role agent false false; } || warp_set_role "${role}" false false ;;
        register) warp_register "${role}" ;;
        status) warp_status ;;
        *) die "Usage: warp enable|disable|register|status [gateway|agent|both] [--required true|false]" ;;
      esac ;;
    service)
      shift
      require_root service
      service_op "${1:-}" "${2:-}" ;;
    validate)
      shift
      validate_config "${1:-}" ;;
    network)
      shift
      require_root network
      [[ "${1:-setup}" == "setup" ]] && network_setup || die "Usage: network setup" ;;
    monitor)
      shift
      require_root monitor
      monitor_menu ;;
    uninstall)
      shift
      require_root uninstall
      uninstall "$([[ "${1:-}" == "--purge" ]] && echo 1 || echo 0)" ;;
    setup)
      shift
      require_root setup
      local bundle=""
      bundle=$(read_input "Bundle path (ZIP or directory)" "")
      install_binaries "${bundle}" both 0
      wizard_pair pair
      network_setup
      apply_tuning balanced
      apply_firewall_role gateway auto
      service_op gateway enable || true
      service_op gateway start || true
      log_ok "One-shot setup completed" ;;
    secret) gen_secret ;;
    *) usage; die "Unknown command: ${cmd}" ;;
  esac
}

if [[ "${STEALTHLINK_CTL_SOURCE_ONLY:-0}" == "1" ]]; then return 0 2>/dev/null || exit 0; fi
main "$@"
